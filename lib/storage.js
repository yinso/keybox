// Generated by CoffeeScript 1.10.0
(function() {
  var DBI, Promise, Storage, fs, path;

  fs = require('fs');

  path = require('path');

  DBI = require('easydbi');

  require('easydbi-sqlite');

  Promise = require('bluebird');

  Storage = (function() {
    Storage.initialize = function(filePath, cb) {
      var setupName;
      setupName = 'storage:' + filePath;
      if (!DBI.hasSetup(setupName)) {
        DBI.setup(setupName, {
          type: 'sqlite',
          options: {
            filePath: filePath
          }
        });
      }
      return DBI.connect(setupName, function(err, conn) {
        var storage;
        if (err) {
          return cb(err);
        } else {
          storage = new Storage(filePath, conn);
          return storage.loadSchema(cb);
        }
      });
    };

    function Storage(filePath, conn) {
      if (!(this instanceof Storage)) {
        (function(func, args, ctor) {
          ctor.prototype = func.prototype;
          var child = new ctor, result = func.apply(child, args);
          return Object(result) === result ? result : child;
        })(Storage, arguments, function(){});
      }
      this.filePath = filePath;
      this.conn = conn;
    }

    Storage.prototype.loadSchema = function(cb) {
      var conn, self;
      self = this;
      conn = self.conn;
      return conn.loadScript(path.join(__dirname, '../schema/sqlite3.sql'), true, function(err) {
        if (err) {
          return cb(err);
        } else {
          return cb(null, self);
        }
      });
    };

    Storage.prototype.set = function(key, val, cb) {
      var conn, self;
      conn = this.conn;
      self = this;
      return conn.beginAsync().then(function() {
        return conn.queryAsync('select 1 from keyvals where key = $key', {
          key: key
        });
      }).then(function(rows) {
        var serialized;
        serialized = self.serialize(val);
        if (rows.length === 0) {
          return conn.execAsync('insert into keyvals (key, value) values ($key, $value)', {
            key: key,
            value: serialized
          });
        } else {
          return conn.execAsync('update keyvals set value = $value where key = $key', {
            key: key,
            value: serialized
          });
        }
      }).then(function() {
        return conn.commitAsync();
      }).then(function() {
        return cb(null);
      })["catch"](function(e) {
        return conn.rollback(function() {
          return cb(e);
        });
      });
    };

    Storage.prototype.get = function(key, cb) {
      var conn, self;
      conn = this.conn;
      self = this;
      return conn.queryAsync('select value from keyvals where key = $key', {
        key: key
      }).then(function(rows) {
        if (rows.length === 0) {
          return cb(null, void 0);
        } else {
          return cb(null, self.deserialize(rows[0].value));
        }
      })["catch"](cb);
    };

    Storage.prototype.serialize = function(val) {
      return JSON.stringify(val);
    };

    Storage.prototype.deserialize = function(val) {
      return JSON.parse(val);
    };

    Storage.prototype["delete"] = function(key, cb) {
      var conn;
      conn = this.conn;
      return conn.execAsync('delete from keyvals where key = $key', {
        key: key
      }).then(function(rows) {
        return cb(null);
      })["catch"](cb);
    };

    Storage.prototype.close = function(cb) {
      return this.conn.disconnect(cb);
    };

    Storage.prototype.destroy = function(cb) {
      return fs.unlink(this.filePath, cb);
    };

    return Storage;

  })();

  Promise.promisifyAll(Storage);

  Promise.promisifyAll(Storage.prototype);

  module.exports = Storage;

}).call(this);
