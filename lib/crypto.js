// Generated by CoffeeScript 1.10.0
(function() {
  var Crypto, Promise, crypto;

  crypto = require('crypto');

  Promise = require('bluebird');

  Crypto = (function() {
    Crypto.hash = function(type, key, cb) {
      var buffer, hash;
      hash = crypto.createHash(type);
      buffer = [];
      hash.on('readable', function() {
        var data;
        data = hash.read();
        if (data) {
          return cb(null, data.toString('hex'));
        }
      });
      hash.write(key);
      return hash.end();
    };

    Crypto.encrypt = function(type, password, data, cb) {
      var c;
      c = new Crypto();
      return c.encrypt(type, password, data, cb);
    };

    Crypto.decrypt = function(password, encrypted, cb) {
      var c;
      c = new Crypto();
      return c.decrypt(password, encrypted, cb);
    };

    Crypto.createKey = function(type, password, salt, cb) {
      var c;
      c = new Crypto();
      return c.createKey(type, password, salt, cb);
    };

    function Crypto(options) {
      if (options == null) {
        options = {};
      }
      if (!(this instanceof Crypto)) {
        return new Crypto(options);
      }
      this.saltSize = options.saltSize || 32;
      this.keyDerivationPass = options.keyDerivationPass || 1024;
    }

    Crypto.prototype.ivSize = function(type) {
      switch (type) {
        case 'aes128':
        case 'aes192':
        case 'aes256':
          return 16;
        case 'aes192':
          return 24;
        case 'aes256':
          return 32;
        default:
          throw new Error("Crypto.ivSize:unknown_cipher: " + type);
      }
    };

    Crypto.prototype.keySize = function(type) {
      switch (type) {
        case 'aes128':
          return 16;
        case 'aes192':
          return 24;
        case 'aes256':
          return 32;
        default:
          throw new Error("Crypt.keySize:unknown_cipher: " + type);
      }
    };

    Crypto.prototype.createIV = function(type, cb) {
      var e, error, size;
      try {
        size = this.ivSize(type);
        return crypto.randomBytes(size, cb);
      } catch (error) {
        e = error;
        return cb(e);
      }
    };

    Crypto.prototype.createSalt = function(cb) {
      return crypto.randomBytes(this.saltSize, cb);
    };

    Crypto.prototype.createKey = function(type, password, salt, cb) {
      var e, error, keyLength;
      try {
        keyLength = this.keySize(type);
        return crypto.pbkdf2(password, salt, this.keyDerivationPass, keyLength, cb);
      } catch (error) {
        e = error;
        return cb(e);
      }
    };

    Crypto.prototype.encrypt = function(type, password, data, cb) {
      var self;
      self = this;
      return self.createSaltAsync().then(function(salt) {
        return self.createKeyAsync(type, password, salt).then(function(key) {
          return self.createIVAsync(type).then(function(iv) {
            return self._encrypt(type, salt, key, iv, data, cb);
          });
        });
      })["catch"](cb);
    };

    Crypto.prototype._encrypt = function(type, salt, key, iv, data, cb) {
      var cipher, res;
      cipher = crypto.createCipheriv(type, key, iv);
      res = [];
      cipher.on('readable', function() {
        data = cipher.read();
        if (data) {
          return res.push(data.toString('hex'));
        }
      });
      cipher.on('end', function() {
        return cb(null, [type, salt.toString('hex'), iv.toString('hex'), res.join('')].join(':'));
      });
      cipher.write(JSON.stringify(data));
      return cipher.end();
    };

    Crypto.prototype.decrypt = function(password, encrypted, cb) {
      var data, iv, ref, salt, self, type;
      ref = encrypted.split(':'), type = ref[0], salt = ref[1], iv = ref[2], data = ref[3];
      salt = new Buffer(salt, 'hex');
      iv = new Buffer(iv, 'hex');
      self = this;
      return self.createKeyAsync(type, password, salt).then(function(key) {
        return self._decrypt(type, key, iv, data, cb);
      })["catch"](cb);
    };

    Crypto.prototype._decrypt = function(type, key, iv, data, cb) {
      var decipher, res;
      decipher = crypto.createDecipheriv(type, key, iv);
      res = [];
      decipher.on('readable', function() {
        data = decipher.read();
        if (data) {
          return res.push(data.toString('utf8'));
        }
      });
      decipher.on('end', function() {
        var e, error;
        try {
          return cb(null, JSON.parse(res.join('')));
        } catch (error) {
          e = error;
          return cb(e);
        }
      });
      decipher.write(data, 'hex');
      return decipher.end();
    };

    return Crypto;

  })();

  Promise.promisifyAll(Crypto);

  Promise.promisifyAll(Crypto.prototype);

  module.exports = Crypto;

}).call(this);
